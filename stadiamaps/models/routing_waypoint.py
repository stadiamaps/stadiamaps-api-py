# coding: utf-8

"""
    Stadia Maps Geospatial APIs

    The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.

    The version of the OpenAPI document: 9.3.0
    Contact: support@stadiamaps.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from stadiamaps.models.routing_waypoint_all_of_search_filter import RoutingWaypointAllOfSearchFilter
from typing import Optional, Set
from typing_extensions import Self

class RoutingWaypoint(BaseModel):
    """
    RoutingWaypoint
    """ # noqa: E501
    lat: Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]] = Field(description="The latitude of a point in the shape.")
    lon: Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]] = Field(description="The longitude of a point in the shape.")
    type: Optional[StrictStr] = Field(default=None, description="A `break` represents the start or end of a leg, and allows reversals. A `through` location is an intermediate waypoint that must be visited between `break`s, but at which reversals are not allowed. A `via` is similar to a `through` except that reversals are allowed. A `break_through` is similar to a `break` in that it can be the start/end of a leg, but does not allow reversals. Defaults to `break`.")
    heading: Optional[Annotated[int, Field(le=360, strict=True, ge=0)]] = Field(default=None, description="The preferred direction of travel when starting the route, in integer clockwise degrees from north. North is 0, south is 180, east is 90, and west is 270.")
    heading_tolerance: Optional[Annotated[int, Field(le=360, strict=True, ge=0)]] = Field(default=60, description="The tolerance (in degrees) determining whether a street is considered the same direction.")
    minimum_reachability: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=50, description="The minimum number of nodes that must be reachable for a given edge to consider that edge as belonging to a connected region. If a candidate edge has fewer connections, it will be considered a disconnected island.")
    radius: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=0, description="The distance (in meters) to look for candidate edges around the location for purposes of snapping locations to the route graph. If there are no candidates within this distance, the closest candidate within a reasonable search distance will be used. This is subject to clamping by internal limits.")
    rank_candidates: Optional[StrictBool] = Field(default=True, description="If true, candidates will be ranked according to their distance from the target location as well as other factors. If false, candidates will only be ranked using their distance from the target.")
    preferred_side: Optional[StrictStr] = Field(default=None, description="If the location is not offset from the road centerline or is closest to an intersection, this option has no effect. Otherwise, the preferred side of street is used to determine whether or not the location should be visited from the same, opposite or either side of the road with respect to the side of the road the given locale drives on.")
    node_snap_tolerance: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=5, description="During edge correlation this is the tolerance (in meters) used to determine whether or not to snap to the intersection rather than along the street, if the snap location is within this distance from the intersection, the intersection is used instead.")
    street_side_tolerance: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=5, description="A tolerance in meters from the edge centerline used for determining the side of the street that the location is on. If the distance to the centerline is less than this tolerance, no side will be inferred. Otherwise, the left or right side will be selected depending on the direction of travel.")
    street_side_max_distance: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=1000, description="A tolerance in meters from the edge centerline used for determining the side of the street that the location is on. If the distance to the centerline is greater than this tolerance, no side will be inferred. Otherwise, the left or right side will be selected depending on the direction of travel.")
    search_filter: Optional[RoutingWaypointAllOfSearchFilter] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["lat", "lon", "type", "heading", "heading_tolerance", "minimum_reachability", "radius", "rank_candidates", "preferred_side", "node_snap_tolerance", "street_side_tolerance", "street_side_max_distance", "search_filter"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['break', 'through', 'via', 'break_through']):
            raise ValueError("must be one of enum values ('break', 'through', 'via', 'break_through')")
        return value

    @field_validator('preferred_side')
    def preferred_side_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['same', 'opposite', 'either']):
            raise ValueError("must be one of enum values ('same', 'opposite', 'either')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RoutingWaypoint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of search_filter
        if self.search_filter:
            _dict['search_filter'] = self.search_filter.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RoutingWaypoint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "lat": obj.get("lat"),
            "lon": obj.get("lon"),
            "type": obj.get("type"),
            "heading": obj.get("heading"),
            "heading_tolerance": obj.get("heading_tolerance") if obj.get("heading_tolerance") is not None else 60,
            "minimum_reachability": obj.get("minimum_reachability") if obj.get("minimum_reachability") is not None else 50,
            "radius": obj.get("radius") if obj.get("radius") is not None else 0,
            "rank_candidates": obj.get("rank_candidates") if obj.get("rank_candidates") is not None else True,
            "preferred_side": obj.get("preferred_side"),
            "node_snap_tolerance": obj.get("node_snap_tolerance") if obj.get("node_snap_tolerance") is not None else 5,
            "street_side_tolerance": obj.get("street_side_tolerance") if obj.get("street_side_tolerance") is not None else 5,
            "street_side_max_distance": obj.get("street_side_max_distance") if obj.get("street_side_max_distance") is not None else 1000,
            "search_filter": RoutingWaypointAllOfSearchFilter.from_dict(obj["search_filter"]) if obj.get("search_filter") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


