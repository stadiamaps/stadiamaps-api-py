# coding: utf-8

"""
    Stadia Maps Geospatial APIs

    The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.

    The version of the OpenAPI document: 9.3.0
    Contact: support@stadiamaps.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from stadiamaps.models.geocoding_layer import GeocodingLayer
from stadiamaps.models.geocoding_source import GeocodingSource
from typing import Optional, Set
from typing_extensions import Self

class SearchStructuredQuery(BaseModel):
    """
    SearchStructuredQuery
    """ # noqa: E501
    address: Optional[StrictStr] = Field(default=None, description="A street name, optionally with a house number.")
    neighbourhood: Optional[StrictStr] = Field(default=None, description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")
    borough: Optional[StrictStr] = Field(default=None, description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")
    locality: Optional[StrictStr] = Field(default=None, description="The city, village, town, etc. that the place/address is part of.")
    county: Optional[StrictStr] = Field(default=None, description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")
    region: Optional[StrictStr] = Field(default=None, description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")
    postalcode: Optional[StrictStr] = Field(default=None, description="A mail sorting code.")
    country: Optional[StrictStr] = Field(default=None, description="A country code in ISO 3116-1 alpha-2 or alpha-3 format.")
    focus_point_lat: Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]] = Field(default=None, description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.", alias="focus.point.lat")
    focus_point_lon: Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]] = Field(default=None, description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.", alias="focus.point.lon")
    boundary_rect_min_lat: Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]] = Field(default=None, description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.", alias="boundary.rect.min_lat")
    boundary_rect_max_lat: Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]] = Field(default=None, description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.", alias="boundary.rect.max_lat")
    boundary_rect_min_lon: Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]] = Field(default=None, description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.", alias="boundary.rect.min_lon")
    boundary_rect_max_lon: Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]] = Field(default=None, description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.", alias="boundary.rect.max_lon")
    boundary_circle_lat: Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]] = Field(default=None, description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.", alias="boundary.circle.lat")
    boundary_circle_lon: Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]] = Field(default=None, description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.", alias="boundary.circle.lon")
    boundary_circle_radius: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.", alias="boundary.circle.radius")
    boundary_country: Optional[List[StrictStr]] = Field(default=None, description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.", alias="boundary.country")
    boundary_gid: Optional[StrictStr] = Field(default=None, description="The GID of an area to limit the search to.", alias="boundary.gid")
    layers: Optional[List[GeocodingLayer]] = Field(default=None, description="A list of layers to limit the search to.")
    sources: Optional[List[GeocodingSource]] = Field(default=None, description="A list of sources to limit the search to.")
    size: Optional[StrictInt] = Field(default=None, description="The maximum number of results to return.")
    lang: Optional[StrictStr] = Field(default=None, description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["address", "neighbourhood", "borough", "locality", "county", "region", "postalcode", "country", "focus.point.lat", "focus.point.lon", "boundary.rect.min_lat", "boundary.rect.max_lat", "boundary.rect.min_lon", "boundary.rect.max_lon", "boundary.circle.lat", "boundary.circle.lon", "boundary.circle.radius", "boundary.country", "boundary.gid", "layers", "sources", "size", "lang"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SearchStructuredQuery from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SearchStructuredQuery from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "address": obj.get("address"),
            "neighbourhood": obj.get("neighbourhood"),
            "borough": obj.get("borough"),
            "locality": obj.get("locality"),
            "county": obj.get("county"),
            "region": obj.get("region"),
            "postalcode": obj.get("postalcode"),
            "country": obj.get("country"),
            "focus.point.lat": obj.get("focus.point.lat"),
            "focus.point.lon": obj.get("focus.point.lon"),
            "boundary.rect.min_lat": obj.get("boundary.rect.min_lat"),
            "boundary.rect.max_lat": obj.get("boundary.rect.max_lat"),
            "boundary.rect.min_lon": obj.get("boundary.rect.min_lon"),
            "boundary.rect.max_lon": obj.get("boundary.rect.max_lon"),
            "boundary.circle.lat": obj.get("boundary.circle.lat"),
            "boundary.circle.lon": obj.get("boundary.circle.lon"),
            "boundary.circle.radius": obj.get("boundary.circle.radius"),
            "boundary.country": obj.get("boundary.country"),
            "boundary.gid": obj.get("boundary.gid"),
            "layers": obj.get("layers"),
            "sources": obj.get("sources"),
            "size": obj.get("size"),
            "lang": obj.get("lang")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


