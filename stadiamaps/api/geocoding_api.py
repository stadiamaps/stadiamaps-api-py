# coding: utf-8

"""
    Stadia Maps Geospatial APIs

    The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.  # noqa: E501

    The version of the OpenAPI document: 5.0.5
    Contact: support@stadiamaps.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, conlist

from typing import Optional, Union

from stadiamaps.models.pelias_layer import PeliasLayer
from stadiamaps.models.pelias_response import PeliasResponse
from stadiamaps.models.pelias_source import PeliasSource

from stadiamaps.api_client import ApiClient
from stadiamaps.api_response import ApiResponse
from stadiamaps.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class GeocodingApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def autocomplete(self, text : Annotated[StrictStr, Field(..., description="The place name (address, venue name, etc.) to search for.")], focus_point_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None, focus_point_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None, boundary_rect_min_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_min_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_circle_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None, boundary_circle_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None, boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> PeliasResponse:  # noqa: E501
        """Search and geocode quickly based on partial input.  # noqa: E501

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.autocomplete(text, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, async_req=True)
        >>> result = thread.get()

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PeliasResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the autocomplete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.autocomplete_with_http_info(text, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, **kwargs)  # noqa: E501

    @validate_arguments
    def autocomplete_with_http_info(self, text : Annotated[StrictStr, Field(..., description="The place name (address, venue name, etc.) to search for.")], focus_point_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None, focus_point_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None, boundary_rect_min_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_min_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_circle_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None, boundary_circle_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None, boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search and geocode quickly based on partial input.  # noqa: E501

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.autocomplete_with_http_info(text, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, async_req=True)
        >>> result = thread.get()

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PeliasResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'text',
            'focus_point_lat',
            'focus_point_lon',
            'boundary_rect_min_lat',
            'boundary_rect_max_lat',
            'boundary_rect_min_lon',
            'boundary_rect_max_lon',
            'boundary_circle_lat',
            'boundary_circle_lon',
            'boundary_circle_radius',
            'boundary_country',
            'boundary_gid',
            'layers',
            'sources',
            'size',
            'lang'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method autocomplete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('text') is not None:  # noqa: E501
            _query_params.append(('text', _params['text']))

        if _params.get('focus_point_lat') is not None:  # noqa: E501
            _query_params.append(('focus.point.lat', _params['focus_point_lat']))

        if _params.get('focus_point_lon') is not None:  # noqa: E501
            _query_params.append(('focus.point.lon', _params['focus_point_lon']))

        if _params.get('boundary_rect_min_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.min_lat', _params['boundary_rect_min_lat']))

        if _params.get('boundary_rect_max_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.max_lat', _params['boundary_rect_max_lat']))

        if _params.get('boundary_rect_min_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.min_lon', _params['boundary_rect_min_lon']))

        if _params.get('boundary_rect_max_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.max_lon', _params['boundary_rect_max_lon']))

        if _params.get('boundary_circle_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.lat', _params['boundary_circle_lat']))

        if _params.get('boundary_circle_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.lon', _params['boundary_circle_lon']))

        if _params.get('boundary_circle_radius') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.radius', _params['boundary_circle_radius']))

        if _params.get('boundary_country') is not None:  # noqa: E501
            _query_params.append(('boundary.country', _params['boundary_country']))
            _collection_formats['boundary.country'] = 'csv'

        if _params.get('boundary_gid') is not None:  # noqa: E501
            _query_params.append(('boundary.gid', _params['boundary_gid']))

        if _params.get('layers') is not None:  # noqa: E501
            _query_params.append(('layers', _params['layers']))
            _collection_formats['layers'] = 'csv'

        if _params.get('sources') is not None:  # noqa: E501
            _query_params.append(('sources', _params['sources']))
            _collection_formats['sources'] = 'csv'

        if _params.get('size') is not None:  # noqa: E501
            _query_params.append(('size', _params['size']))

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "PeliasResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/geocoding/v1/autocomplete', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def place(self, ids : Annotated[conlist(StrictStr, min_items=1), Field(..., description="A list of Pelias GIDs to search for.")], lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> PeliasResponse:  # noqa: E501
        """Retrieve details of a place using its GID.  # noqa: E501

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that these IDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.place(ids, lang, async_req=True)
        >>> result = thread.get()

        :param ids: A list of Pelias GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PeliasResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the place_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.place_with_http_info(ids, lang, **kwargs)  # noqa: E501

    @validate_arguments
    def place_with_http_info(self, ids : Annotated[conlist(StrictStr, min_items=1), Field(..., description="A list of Pelias GIDs to search for.")], lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve details of a place using its GID.  # noqa: E501

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that these IDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.place_with_http_info(ids, lang, async_req=True)
        >>> result = thread.get()

        :param ids: A list of Pelias GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PeliasResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ids',
            'lang'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method place" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ids') is not None:  # noqa: E501
            _query_params.append(('ids', _params['ids']))
            _collection_formats['ids'] = 'csv'

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "PeliasResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/geocoding/v1/place', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def reverse(self, point_lat : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The latitude of the point at which to perform the search.")], point_lon : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The longitude of the point at which to perform the search.")], boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> PeliasResponse:  # noqa: E501
        """Find places and addresses near geographic coordinates (reverse geocoding).  # noqa: E501

        Reverse geocoding and search finds places and addresses near any geographic coordinates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reverse(point_lat, point_lon, boundary_circle_radius, layers, sources, boundary_country, boundary_gid, size, lang, async_req=True)
        >>> result = thread.get()

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PeliasResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the reverse_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.reverse_with_http_info(point_lat, point_lon, boundary_circle_radius, layers, sources, boundary_country, boundary_gid, size, lang, **kwargs)  # noqa: E501

    @validate_arguments
    def reverse_with_http_info(self, point_lat : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The latitude of the point at which to perform the search.")], point_lon : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The longitude of the point at which to perform the search.")], boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Find places and addresses near geographic coordinates (reverse geocoding).  # noqa: E501

        Reverse geocoding and search finds places and addresses near any geographic coordinates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reverse_with_http_info(point_lat, point_lon, boundary_circle_radius, layers, sources, boundary_country, boundary_gid, size, lang, async_req=True)
        >>> result = thread.get()

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PeliasResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'point_lat',
            'point_lon',
            'boundary_circle_radius',
            'layers',
            'sources',
            'boundary_country',
            'boundary_gid',
            'size',
            'lang'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reverse" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('point_lat') is not None:  # noqa: E501
            _query_params.append(('point.lat', _params['point_lat']))

        if _params.get('point_lon') is not None:  # noqa: E501
            _query_params.append(('point.lon', _params['point_lon']))

        if _params.get('boundary_circle_radius') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.radius', _params['boundary_circle_radius']))

        if _params.get('layers') is not None:  # noqa: E501
            _query_params.append(('layers', _params['layers']))
            _collection_formats['layers'] = 'csv'

        if _params.get('sources') is not None:  # noqa: E501
            _query_params.append(('sources', _params['sources']))
            _collection_formats['sources'] = 'csv'

        if _params.get('boundary_country') is not None:  # noqa: E501
            _query_params.append(('boundary.country', _params['boundary_country']))
            _collection_formats['boundary.country'] = 'csv'

        if _params.get('boundary_gid') is not None:  # noqa: E501
            _query_params.append(('boundary.gid', _params['boundary_gid']))

        if _params.get('size') is not None:  # noqa: E501
            _query_params.append(('size', _params['size']))

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "PeliasResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/geocoding/v1/reverse', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search(self, text : Annotated[StrictStr, Field(..., description="The place name (address, venue name, etc.) to search for.")], focus_point_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None, focus_point_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None, boundary_rect_min_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_min_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_circle_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None, boundary_circle_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None, boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> PeliasResponse:  # noqa: E501
        """Search for location and other info using a place name or address (forward geocoding).  # noqa: E501

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search(text, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, async_req=True)
        >>> result = thread.get()

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PeliasResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the search_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.search_with_http_info(text, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, **kwargs)  # noqa: E501

    @validate_arguments
    def search_with_http_info(self, text : Annotated[StrictStr, Field(..., description="The place name (address, venue name, etc.) to search for.")], focus_point_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None, focus_point_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None, boundary_rect_min_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_min_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_circle_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None, boundary_circle_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None, boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Search for location and other info using a place name or address (forward geocoding).  # noqa: E501

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_with_http_info(text, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, async_req=True)
        >>> result = thread.get()

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PeliasResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'text',
            'focus_point_lat',
            'focus_point_lon',
            'boundary_rect_min_lat',
            'boundary_rect_max_lat',
            'boundary_rect_min_lon',
            'boundary_rect_max_lon',
            'boundary_circle_lat',
            'boundary_circle_lon',
            'boundary_circle_radius',
            'boundary_country',
            'boundary_gid',
            'layers',
            'sources',
            'size',
            'lang'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('text') is not None:  # noqa: E501
            _query_params.append(('text', _params['text']))

        if _params.get('focus_point_lat') is not None:  # noqa: E501
            _query_params.append(('focus.point.lat', _params['focus_point_lat']))

        if _params.get('focus_point_lon') is not None:  # noqa: E501
            _query_params.append(('focus.point.lon', _params['focus_point_lon']))

        if _params.get('boundary_rect_min_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.min_lat', _params['boundary_rect_min_lat']))

        if _params.get('boundary_rect_max_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.max_lat', _params['boundary_rect_max_lat']))

        if _params.get('boundary_rect_min_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.min_lon', _params['boundary_rect_min_lon']))

        if _params.get('boundary_rect_max_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.max_lon', _params['boundary_rect_max_lon']))

        if _params.get('boundary_circle_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.lat', _params['boundary_circle_lat']))

        if _params.get('boundary_circle_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.lon', _params['boundary_circle_lon']))

        if _params.get('boundary_circle_radius') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.radius', _params['boundary_circle_radius']))

        if _params.get('boundary_country') is not None:  # noqa: E501
            _query_params.append(('boundary.country', _params['boundary_country']))
            _collection_formats['boundary.country'] = 'csv'

        if _params.get('boundary_gid') is not None:  # noqa: E501
            _query_params.append(('boundary.gid', _params['boundary_gid']))

        if _params.get('layers') is not None:  # noqa: E501
            _query_params.append(('layers', _params['layers']))
            _collection_formats['layers'] = 'csv'

        if _params.get('sources') is not None:  # noqa: E501
            _query_params.append(('sources', _params['sources']))
            _collection_formats['sources'] = 'csv'

        if _params.get('size') is not None:  # noqa: E501
            _query_params.append(('size', _params['size']))

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "PeliasResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/geocoding/v1/search', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def search_structured(self, address : Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None, neighbourhood : Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None, borough : Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None, locality : Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None, county : Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None, region : Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None, postalcode : Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None, country : Annotated[Optional[StrictStr], Field(description="A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.")] = None, focus_point_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None, focus_point_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None, boundary_rect_min_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_min_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_circle_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None, boundary_circle_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None, boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> PeliasResponse:  # noqa: E501
        """Find locations matching components (structured forward geocoding).  # noqa: E501

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_structured(address, neighbourhood, borough, locality, county, region, postalcode, country, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, async_req=True)
        >>> result = thread.get()

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PeliasResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the search_structured_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.search_structured_with_http_info(address, neighbourhood, borough, locality, county, region, postalcode, country, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, **kwargs)  # noqa: E501

    @validate_arguments
    def search_structured_with_http_info(self, address : Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None, neighbourhood : Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None, borough : Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None, locality : Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None, county : Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None, region : Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None, postalcode : Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None, country : Annotated[Optional[StrictStr], Field(description="A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.")] = None, focus_point_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None, focus_point_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None, boundary_rect_min_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_min_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_rect_max_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None, boundary_circle_lat : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None, boundary_circle_lon : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None, boundary_circle_radius : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None, boundary_country : Annotated[Optional[conlist(StrictStr)], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None, boundary_gid : Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None, layers : Annotated[Optional[conlist(PeliasLayer)], Field(description="A list of layers to limit the search to.")] = None, sources : Annotated[Optional[conlist(PeliasSource)], Field(description="A list of sources to limit the search to.")] = None, size : Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None, lang : Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Find locations matching components (structured forward geocoding).  # noqa: E501

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_structured_with_http_info(address, neighbourhood, borough, locality, county, region, postalcode, country, focus_point_lat, focus_point_lon, boundary_rect_min_lat, boundary_rect_max_lat, boundary_rect_min_lon, boundary_rect_max_lon, boundary_circle_lat, boundary_circle_lon, boundary_circle_radius, boundary_country, boundary_gid, layers, sources, size, lang, async_req=True)
        >>> result = thread.get()

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PeliasResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'address',
            'neighbourhood',
            'borough',
            'locality',
            'county',
            'region',
            'postalcode',
            'country',
            'focus_point_lat',
            'focus_point_lon',
            'boundary_rect_min_lat',
            'boundary_rect_max_lat',
            'boundary_rect_min_lon',
            'boundary_rect_max_lon',
            'boundary_circle_lat',
            'boundary_circle_lon',
            'boundary_circle_radius',
            'boundary_country',
            'boundary_gid',
            'layers',
            'sources',
            'size',
            'lang'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_structured" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('address') is not None:  # noqa: E501
            _query_params.append(('address', _params['address']))

        if _params.get('neighbourhood') is not None:  # noqa: E501
            _query_params.append(('neighbourhood', _params['neighbourhood']))

        if _params.get('borough') is not None:  # noqa: E501
            _query_params.append(('borough', _params['borough']))

        if _params.get('locality') is not None:  # noqa: E501
            _query_params.append(('locality', _params['locality']))

        if _params.get('county') is not None:  # noqa: E501
            _query_params.append(('county', _params['county']))

        if _params.get('region') is not None:  # noqa: E501
            _query_params.append(('region', _params['region']))

        if _params.get('postalcode') is not None:  # noqa: E501
            _query_params.append(('postalcode', _params['postalcode']))

        if _params.get('country') is not None:  # noqa: E501
            _query_params.append(('country', _params['country']))

        if _params.get('focus_point_lat') is not None:  # noqa: E501
            _query_params.append(('focus.point.lat', _params['focus_point_lat']))

        if _params.get('focus_point_lon') is not None:  # noqa: E501
            _query_params.append(('focus.point.lon', _params['focus_point_lon']))

        if _params.get('boundary_rect_min_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.min_lat', _params['boundary_rect_min_lat']))

        if _params.get('boundary_rect_max_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.max_lat', _params['boundary_rect_max_lat']))

        if _params.get('boundary_rect_min_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.min_lon', _params['boundary_rect_min_lon']))

        if _params.get('boundary_rect_max_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.rect.max_lon', _params['boundary_rect_max_lon']))

        if _params.get('boundary_circle_lat') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.lat', _params['boundary_circle_lat']))

        if _params.get('boundary_circle_lon') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.lon', _params['boundary_circle_lon']))

        if _params.get('boundary_circle_radius') is not None:  # noqa: E501
            _query_params.append(('boundary.circle.radius', _params['boundary_circle_radius']))

        if _params.get('boundary_country') is not None:  # noqa: E501
            _query_params.append(('boundary.country', _params['boundary_country']))
            _collection_formats['boundary.country'] = 'csv'

        if _params.get('boundary_gid') is not None:  # noqa: E501
            _query_params.append(('boundary.gid', _params['boundary_gid']))

        if _params.get('layers') is not None:  # noqa: E501
            _query_params.append(('layers', _params['layers']))
            _collection_formats['layers'] = 'csv'

        if _params.get('sources') is not None:  # noqa: E501
            _query_params.append(('sources', _params['sources']))
            _collection_formats['sources'] = 'csv'

        if _params.get('size') is not None:  # noqa: E501
            _query_params.append(('size', _params['size']))

        if _params.get('lang') is not None:  # noqa: E501
            _query_params.append(('lang', _params['lang']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['ApiKeyAuth']  # noqa: E501

        _response_types_map = {
            '200': "PeliasResponse",
            '400': None,
        }

        return self.api_client.call_api(
            '/geocoding/v1/search/structured', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
