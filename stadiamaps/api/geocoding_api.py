# coding: utf-8

"""
    Stadia Maps Geospatial APIs

    The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.

    The version of the OpenAPI document: 6.3.0
    Contact: support@stadiamaps.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from stadiamaps.models.pelias_layer import PeliasLayer
from stadiamaps.models.pelias_response import PeliasResponse
from stadiamaps.models.pelias_source import PeliasSource

from stadiamaps.api_client import ApiClient, RequestSerialized
from stadiamaps.api_response import ApiResponse
from stadiamaps.rest import RESTResponseType


class GeocodingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def autocomplete(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PeliasResponse:
        """Search and geocode quickly based on partial input.

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def autocomplete_with_http_info(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PeliasResponse]:
        """Search and geocode quickly based on partial input.

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def autocomplete_without_preload_content(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search and geocode quickly based on partial input.

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _autocomplete_serialize(
        self,
        text,
        focus_point_lat,
        focus_point_lon,
        boundary_rect_min_lat,
        boundary_rect_max_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        boundary_country,
        boundary_gid,
        layers,
        sources,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'boundary.country': 'csv',
            'layers': 'csv',
            'sources': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if text is not None:
            
            _query_params.append(('text', text))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/autocomplete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place(
        self,
        ids: Annotated[List[StrictStr], Field(min_length=1, description="A list of Pelias GIDs to search for.")],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PeliasResponse:
        """Retrieve details of a place using its GID.

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that these IDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.

        :param ids: A list of Pelias GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_with_http_info(
        self,
        ids: Annotated[List[StrictStr], Field(min_length=1, description="A list of Pelias GIDs to search for.")],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PeliasResponse]:
        """Retrieve details of a place using its GID.

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that these IDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.

        :param ids: A list of Pelias GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_without_preload_content(
        self,
        ids: Annotated[List[StrictStr], Field(min_length=1, description="A list of Pelias GIDs to search for.")],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve details of a place using its GID.

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that these IDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.

        :param ids: A list of Pelias GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_serialize(
        self,
        ids,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/place',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reverse(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PeliasResponse:
        """Find places and addresses near geographic coordinates (reverse geocoding).

        Reverse geocoding and search finds places and addresses near any geographic coordinates.

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            boundary_circle_radius=boundary_circle_radius,
            layers=layers,
            sources=sources,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reverse_with_http_info(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PeliasResponse]:
        """Find places and addresses near geographic coordinates (reverse geocoding).

        Reverse geocoding and search finds places and addresses near any geographic coordinates.

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            boundary_circle_radius=boundary_circle_radius,
            layers=layers,
            sources=sources,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reverse_without_preload_content(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find places and addresses near geographic coordinates (reverse geocoding).

        Reverse geocoding and search finds places and addresses near any geographic coordinates.

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            boundary_circle_radius=boundary_circle_radius,
            layers=layers,
            sources=sources,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reverse_serialize(
        self,
        point_lat,
        point_lon,
        boundary_circle_radius,
        layers,
        sources,
        boundary_country,
        boundary_gid,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'layers': 'csv',
            'sources': 'csv',
            'boundary.country': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if point_lat is not None:
            
            _query_params.append(('point.lat', point_lat))
            
        if point_lon is not None:
            
            _query_params.append(('point.lon', point_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/reverse',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PeliasResponse:
        """Search for location and other info using a place name or address (forward geocoding).

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_with_http_info(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PeliasResponse]:
        """Search for location and other info using a place name or address (forward geocoding).

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_without_preload_content(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for location and other info using a place name or address (forward geocoding).

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_serialize(
        self,
        text,
        focus_point_lat,
        focus_point_lon,
        boundary_rect_min_lat,
        boundary_rect_max_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        boundary_country,
        boundary_gid,
        layers,
        sources,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'boundary.country': 'csv',
            'layers': 'csv',
            'sources': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if text is not None:
            
            _query_params.append(('text', text))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_structured(
        self,
        address: Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None,
        neighbourhood: Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None,
        borough: Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None,
        locality: Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None,
        county: Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None,
        postalcode: Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.")] = None,
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PeliasResponse:
        """Find locations matching components (structured forward geocoding).

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_structured_serialize(
            address=address,
            neighbourhood=neighbourhood,
            borough=borough,
            locality=locality,
            county=county,
            region=region,
            postalcode=postalcode,
            country=country,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_structured_with_http_info(
        self,
        address: Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None,
        neighbourhood: Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None,
        borough: Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None,
        locality: Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None,
        county: Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None,
        postalcode: Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.")] = None,
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PeliasResponse]:
        """Find locations matching components (structured forward geocoding).

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_structured_serialize(
            address=address,
            neighbourhood=neighbourhood,
            borough=borough,
            locality=locality,
            county=county,
            region=region,
            postalcode=postalcode,
            country=country,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_structured_without_preload_content(
        self,
        address: Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None,
        neighbourhood: Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None,
        borough: Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None,
        locality: Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None,
        county: Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None,
        postalcode: Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.")] = None,
        focus_point_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The Pelias GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[PeliasLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[PeliasSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find locations matching components (structured forward geocoding).

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A full name (ex: Canada), or a 2 or 3 character ISO code. Prefer ISO codes when possible.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of countries to limit the search to. These may be either full names (ex: Canada), or an ISO 3116-1 alpha-2 or alpha-3 code. Prefer ISO codes when possible.
        :type boundary_country: List[str]
        :param boundary_gid: The Pelias GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[PeliasLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[PeliasSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_structured_serialize(
            address=address,
            neighbourhood=neighbourhood,
            borough=borough,
            locality=locality,
            county=county,
            region=region,
            postalcode=postalcode,
            country=country,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PeliasResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_structured_serialize(
        self,
        address,
        neighbourhood,
        borough,
        locality,
        county,
        region,
        postalcode,
        country,
        focus_point_lat,
        focus_point_lon,
        boundary_rect_min_lat,
        boundary_rect_max_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        boundary_country,
        boundary_gid,
        layers,
        sources,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'boundary.country': 'csv',
            'layers': 'csv',
            'sources': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if address is not None:
            
            _query_params.append(('address', address))
            
        if neighbourhood is not None:
            
            _query_params.append(('neighbourhood', neighbourhood))
            
        if borough is not None:
            
            _query_params.append(('borough', borough))
            
        if locality is not None:
            
            _query_params.append(('locality', locality))
            
        if county is not None:
            
            _query_params.append(('county', county))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if postalcode is not None:
            
            _query_params.append(('postalcode', postalcode))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/search/structured',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


