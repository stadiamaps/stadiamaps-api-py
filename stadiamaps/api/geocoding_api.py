# coding: utf-8

"""
    Stadia Maps Geospatial APIs

    The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.

    The version of the OpenAPI document: 9.3.0
    Contact: support@stadiamaps.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from stadiamaps.models.bulk_request import BulkRequest
from stadiamaps.models.bulk_search_response import BulkSearchResponse
from stadiamaps.models.geocode_response import GeocodeResponse
from stadiamaps.models.geocode_response_envelope_properties_v2 import GeocodeResponseEnvelopePropertiesV2
from stadiamaps.models.geocoding_layer import GeocodingLayer
from stadiamaps.models.geocoding_source import GeocodingSource
from stadiamaps.models.layer_id import LayerId
from stadiamaps.models.source_id import SourceId

from stadiamaps.api_client import ApiClient, RequestSerialized
from stadiamaps.api_response import ApiResponse
from stadiamaps.rest import RESTResponseType


class GeocodingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def autocomplete(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponse:
        """Search and geocode quickly based on partial input.

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def autocomplete_with_http_info(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponse]:
        """Search and geocode quickly based on partial input.

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def autocomplete_without_preload_content(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search and geocode quickly based on partial input.

        Autocomplete enables interactive search-as-you-type user experiences, suggesting places as you type, along with information that will help your users find the correct place quickly.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _autocomplete_serialize(
        self,
        text,
        focus_point_lat,
        focus_point_lon,
        boundary_rect_min_lat,
        boundary_rect_max_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        boundary_country,
        boundary_gid,
        layers,
        sources,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'boundary.country': 'csv',
            'layers': 'csv',
            'sources': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if text is not None:
            
            _query_params.append(('text', text))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/autocomplete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def autocomplete_v2(
        self,
        text: Annotated[StrictStr, Field(description="The text to search for (the start of an address, place name, etc.).")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.")] = None,
        layers: Annotated[Optional[List[LayerId]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[SourceId]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The minimum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The minimum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The maximum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The maximum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lon.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lat.")] = None,
        boundary_circle_radius: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The radius of the circle (in kilometers) to limit the search to.  NOTE: Requires the other boundary.circle parameters to take effect. Defaults to 50km if unspecified.")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=1)]], Field(description="The maximum number of items to return from a query.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponseEnvelopePropertiesV2:
        """autocomplete_v2


        :param text: The text to search for (the start of an address, place name, etc.). (required)
        :type text: str
        :param focus_point_lat: The latitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.
        :type focus_point_lon: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[LayerId]
        :param sources: A list of sources to limit the search to.
        :type sources: List[SourceId]
        :param boundary_gid: The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.
        :type boundary_gid: str
        :param boundary_country: A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.
        :type boundary_country: List[str]
        :param boundary_rect_min_lat: The minimum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_min_lon: The minimum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lat: The maximum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_max_lon: The maximum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lon.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lat.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to.  NOTE: Requires the other boundary.circle parameters to take effect. Defaults to 50km if unspecified.
        :type boundary_circle_radius: int
        :param size: The maximum number of items to return from a query.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_v2_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            layers=layers,
            sources=sources,
            boundary_gid=boundary_gid,
            boundary_country=boundary_country,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def autocomplete_v2_with_http_info(
        self,
        text: Annotated[StrictStr, Field(description="The text to search for (the start of an address, place name, etc.).")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.")] = None,
        layers: Annotated[Optional[List[LayerId]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[SourceId]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The minimum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The minimum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The maximum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The maximum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lon.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lat.")] = None,
        boundary_circle_radius: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The radius of the circle (in kilometers) to limit the search to.  NOTE: Requires the other boundary.circle parameters to take effect. Defaults to 50km if unspecified.")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=1)]], Field(description="The maximum number of items to return from a query.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponseEnvelopePropertiesV2]:
        """autocomplete_v2


        :param text: The text to search for (the start of an address, place name, etc.). (required)
        :type text: str
        :param focus_point_lat: The latitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.
        :type focus_point_lon: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[LayerId]
        :param sources: A list of sources to limit the search to.
        :type sources: List[SourceId]
        :param boundary_gid: The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.
        :type boundary_gid: str
        :param boundary_country: A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.
        :type boundary_country: List[str]
        :param boundary_rect_min_lat: The minimum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_min_lon: The minimum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lat: The maximum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_max_lon: The maximum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lon.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lat.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to.  NOTE: Requires the other boundary.circle parameters to take effect. Defaults to 50km if unspecified.
        :type boundary_circle_radius: int
        :param size: The maximum number of items to return from a query.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_v2_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            layers=layers,
            sources=sources,
            boundary_gid=boundary_gid,
            boundary_country=boundary_country,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def autocomplete_v2_without_preload_content(
        self,
        text: Annotated[StrictStr, Field(description="The text to search for (the start of an address, place name, etc.).")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.")] = None,
        layers: Annotated[Optional[List[LayerId]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[SourceId]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The minimum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The minimum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The maximum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The maximum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lon.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lat.")] = None,
        boundary_circle_radius: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The radius of the circle (in kilometers) to limit the search to.  NOTE: Requires the other boundary.circle parameters to take effect. Defaults to 50km if unspecified.")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=1)]], Field(description="The maximum number of items to return from a query.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """autocomplete_v2


        :param text: The text to search for (the start of an address, place name, etc.). (required)
        :type text: str
        :param focus_point_lat: The latitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of a focus point.  If provided (along with longitude), the search results should be more locally relevant.
        :type focus_point_lon: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[LayerId]
        :param sources: A list of sources to limit the search to.
        :type sources: List[SourceId]
        :param boundary_gid: The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.
        :type boundary_gid: str
        :param boundary_country: A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.
        :type boundary_country: List[str]
        :param boundary_rect_min_lat: The minimum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_min_lon: The minimum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lat: The maximum latitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_max_lon: The maximum longitude component of a search bounding box.  NOTE: Requires all other boundary.rect parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lon.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to.  NOTE: Requires boundary.circle.lat.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to.  NOTE: Requires the other boundary.circle parameters to take effect. Defaults to 50km if unspecified.
        :type boundary_circle_radius: int
        :param size: The maximum number of items to return from a query.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._autocomplete_v2_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            layers=layers,
            sources=sources,
            boundary_gid=boundary_gid,
            boundary_country=boundary_country,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _autocomplete_v2_serialize(
        self,
        text,
        focus_point_lat,
        focus_point_lon,
        layers,
        sources,
        boundary_gid,
        boundary_country,
        boundary_rect_min_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lat,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'layers': 'csv',
            'sources': 'csv',
            'boundary.country': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if text is not None:
            
            _query_params.append(('text', text))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v2/autocomplete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_details(
        self,
        ids: Annotated[List[StrictStr], Field(description="A list of GIDs to search for.")],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponse:
        """Retrieve details of a place using its GID.

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that GIDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.

        :param ids: A list of GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_details_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_details_with_http_info(
        self,
        ids: Annotated[List[StrictStr], Field(description="A list of GIDs to search for.")],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponse]:
        """Retrieve details of a place using its GID.

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that GIDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.

        :param ids: A list of GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_details_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_details_without_preload_content(
        self,
        ids: Annotated[List[StrictStr], Field(description="A list of GIDs to search for.")],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve details of a place using its GID.

        Many search result components include an associated GID field (for example, an address may have a `localadmin_gid`). The place endpoint lets you look up these places directly by ID. Note that GIDs are not stable for all sources. See the [online documentation](https://docs.stadiamaps.com/geocoding-search-autocomplete/place-lookup/) for details.

        :param ids: A list of GIDs to search for. (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_details_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_details_serialize(
        self,
        ids,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/place',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_details_v2(
        self,
        ids: List[StrictStr],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponseEnvelopePropertiesV2:
        """place_details_v2


        :param ids: (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_details_v2_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_details_v2_with_http_info(
        self,
        ids: List[StrictStr],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponseEnvelopePropertiesV2]:
        """place_details_v2


        :param ids: (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_details_v2_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_details_v2_without_preload_content(
        self,
        ids: List[StrictStr],
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """place_details_v2


        :param ids: (required)
        :type ids: List[str]
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_details_v2_serialize(
            ids=ids,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_details_v2_serialize(
        self,
        ids,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v2/place_details',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reverse(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponse:
        """Find places and addresses near geographic coordinates (reverse geocoding).

        Reverse geocoding and search finds places and addresses near any geographic coordinates.

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            boundary_circle_radius=boundary_circle_radius,
            layers=layers,
            sources=sources,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reverse_with_http_info(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponse]:
        """Find places and addresses near geographic coordinates (reverse geocoding).

        Reverse geocoding and search finds places and addresses near any geographic coordinates.

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            boundary_circle_radius=boundary_circle_radius,
            layers=layers,
            sources=sources,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reverse_without_preload_content(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find places and addresses near geographic coordinates (reverse geocoding).

        Reverse geocoding and search finds places and addresses near any geographic coordinates.

        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            boundary_circle_radius=boundary_circle_radius,
            layers=layers,
            sources=sources,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reverse_serialize(
        self,
        point_lat,
        point_lon,
        boundary_circle_radius,
        layers,
        sources,
        boundary_country,
        boundary_gid,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'layers': 'csv',
            'sources': 'csv',
            'boundary.country': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if point_lat is not None:
            
            _query_params.append(('point.lat', point_lat))
            
        if point_lon is not None:
            
            _query_params.append(('point.lon', point_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/reverse',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reverse_v2(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        layers: Annotated[Optional[List[LayerId]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[SourceId]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.")] = None,
        boundary_circle_radius: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=0)]], Field(description="The radius of the circle (in kilometers) to limit the search to.  Defaults to 1km if unspecified.")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=1)]], Field(description="The maximum number of items to return from a query.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponseEnvelopePropertiesV2:
        """reverse_v2


        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[LayerId]
        :param sources: A list of sources to limit the search to.
        :type sources: List[SourceId]
        :param boundary_gid: The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.
        :type boundary_gid: str
        :param boundary_country: A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.
        :type boundary_country: List[str]
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to.  Defaults to 1km if unspecified.
        :type boundary_circle_radius: int
        :param size: The maximum number of items to return from a query.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_v2_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            layers=layers,
            sources=sources,
            boundary_gid=boundary_gid,
            boundary_country=boundary_country,
            boundary_circle_radius=boundary_circle_radius,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reverse_v2_with_http_info(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        layers: Annotated[Optional[List[LayerId]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[SourceId]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.")] = None,
        boundary_circle_radius: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=0)]], Field(description="The radius of the circle (in kilometers) to limit the search to.  Defaults to 1km if unspecified.")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=1)]], Field(description="The maximum number of items to return from a query.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponseEnvelopePropertiesV2]:
        """reverse_v2


        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[LayerId]
        :param sources: A list of sources to limit the search to.
        :type sources: List[SourceId]
        :param boundary_gid: The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.
        :type boundary_gid: str
        :param boundary_country: A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.
        :type boundary_country: List[str]
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to.  Defaults to 1km if unspecified.
        :type boundary_circle_radius: int
        :param size: The maximum number of items to return from a query.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_v2_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            layers=layers,
            sources=sources,
            boundary_gid=boundary_gid,
            boundary_country=boundary_country,
            boundary_circle_radius=boundary_circle_radius,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reverse_v2_without_preload_content(
        self,
        point_lat: Annotated[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]], Field(description="The latitude of the point at which to perform the search.")],
        point_lon: Annotated[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]], Field(description="The longitude of the point at which to perform the search.")],
        layers: Annotated[Optional[List[LayerId]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[SourceId]], Field(description="A list of sources to limit the search to.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.")] = None,
        boundary_circle_radius: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=0)]], Field(description="The radius of the circle (in kilometers) to limit the search to.  Defaults to 1km if unspecified.")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=25, strict=True, ge=1)]], Field(description="The maximum number of items to return from a query.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """reverse_v2


        :param point_lat: The latitude of the point at which to perform the search. (required)
        :type point_lat: float
        :param point_lon: The longitude of the point at which to perform the search. (required)
        :type point_lon: float
        :param layers: A list of layers to limit the search to.
        :type layers: List[LayerId]
        :param sources: A list of sources to limit the search to.
        :type sources: List[SourceId]
        :param boundary_gid: The GID of a region to limit the search to.  Note: these are not stable for all datasets! For example, OSM features may be deleted and re-added with a new ID.
        :type boundary_gid: str
        :param boundary_country: A list of comma-separated country codes in ISO 3116-1 alpha-2 or alpha-3 format. The search will be limited to these countries.
        :type boundary_country: List[str]
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to.  Defaults to 1km if unspecified.
        :type boundary_circle_radius: int
        :param size: The maximum number of items to return from a query.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. There is no default value, so place names will be returned as-is, which is usually in the local language. NOTE: The Accept-Language header is also respected, and many user agents will set it automatically.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reverse_v2_serialize(
            point_lat=point_lat,
            point_lon=point_lon,
            layers=layers,
            sources=sources,
            boundary_gid=boundary_gid,
            boundary_country=boundary_country,
            boundary_circle_radius=boundary_circle_radius,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponseEnvelopePropertiesV2",
            '400': "GeocodeResponseEnvelopePropertiesV2",
            '500': "GeocodeResponseEnvelopePropertiesV2",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reverse_v2_serialize(
        self,
        point_lat,
        point_lon,
        layers,
        sources,
        boundary_gid,
        boundary_country,
        boundary_circle_radius,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'layers': 'csv',
            'sources': 'csv',
            'boundary.country': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if point_lat is not None:
            
            _query_params.append(('point.lat', point_lat))
            
        if point_lon is not None:
            
            _query_params.append(('point.lon', point_lon))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v2/reverse',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponse:
        """Search for location and other info using a place name or address (forward geocoding).

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_with_http_info(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponse]:
        """Search for location and other info using a place name or address (forward geocoding).

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_without_preload_content(
        self,
        text: Annotated[StrictStr, Field(description="The place name (address, venue name, etc.) to search for.")],
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for location and other info using a place name or address (forward geocoding).

        The search endpoint lets you search for addresses, points of interest, and administrative areas. This is most commonly used for forward geocoding applications where you need to find the geographic coordinates of an address.

        :param text: The place name (address, venue name, etc.) to search for. (required)
        :type text: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_serialize(
            text=text,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_serialize(
        self,
        text,
        focus_point_lat,
        focus_point_lon,
        boundary_rect_min_lat,
        boundary_rect_max_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        boundary_country,
        boundary_gid,
        layers,
        sources,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'boundary.country': 'csv',
            'layers': 'csv',
            'sources': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if text is not None:
            
            _query_params.append(('text', text))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_bulk(
        self,
        bulk_request: Optional[List[BulkRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BulkSearchResponse]:
        """Quickly run a batch of geocoding queries against the search or structured search endpoints.

        The batch endpoint lets you specify many search or structured search requests at once. Once received, all requests will be processed internally on our infrastructure, improving throughput when you need to do a lot of queries.

        :param bulk_request:
        :type bulk_request: List[BulkRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_bulk_serialize(
            bulk_request=bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BulkSearchResponse]",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_bulk_with_http_info(
        self,
        bulk_request: Optional[List[BulkRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BulkSearchResponse]]:
        """Quickly run a batch of geocoding queries against the search or structured search endpoints.

        The batch endpoint lets you specify many search or structured search requests at once. Once received, all requests will be processed internally on our infrastructure, improving throughput when you need to do a lot of queries.

        :param bulk_request:
        :type bulk_request: List[BulkRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_bulk_serialize(
            bulk_request=bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BulkSearchResponse]",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_bulk_without_preload_content(
        self,
        bulk_request: Optional[List[BulkRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Quickly run a batch of geocoding queries against the search or structured search endpoints.

        The batch endpoint lets you specify many search or structured search requests at once. Once received, all requests will be processed internally on our infrastructure, improving throughput when you need to do a lot of queries.

        :param bulk_request:
        :type bulk_request: List[BulkRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_bulk_serialize(
            bulk_request=bulk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BulkSearchResponse]",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_bulk_serialize(
        self,
        bulk_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'BulkRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_request is not None:
            _body_params = bulk_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/geocoding/v1/search/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_structured(
        self,
        address: Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None,
        neighbourhood: Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None,
        borough: Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None,
        locality: Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None,
        county: Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None,
        postalcode: Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeocodeResponse:
        """Find locations matching components (structured forward geocoding).

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_structured_serialize(
            address=address,
            neighbourhood=neighbourhood,
            borough=borough,
            locality=locality,
            county=county,
            region=region,
            postalcode=postalcode,
            country=country,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_structured_with_http_info(
        self,
        address: Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None,
        neighbourhood: Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None,
        borough: Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None,
        locality: Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None,
        county: Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None,
        postalcode: Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeocodeResponse]:
        """Find locations matching components (structured forward geocoding).

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_structured_serialize(
            address=address,
            neighbourhood=neighbourhood,
            borough=borough,
            locality=locality,
            county=county,
            region=region,
            postalcode=postalcode,
            country=country,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_structured_without_preload_content(
        self,
        address: Annotated[Optional[StrictStr], Field(description="A street name, optionally with a house number.")] = None,
        neighbourhood: Annotated[Optional[StrictStr], Field(description="Varies by area, but has a locally specific meaning (NOT always an official administrative unit).")] = None,
        borough: Annotated[Optional[StrictStr], Field(description="A unit within a city (not widely used, but present in places like NYC and Mexico City).")] = None,
        locality: Annotated[Optional[StrictStr], Field(description="The city, village, town, etc. that the place/address is part of.")] = None,
        county: Annotated[Optional[StrictStr], Field(description="Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="Typically the first administrative division within a country. For example, a US state or a Canadian province.")] = None,
        postalcode: Annotated[Optional[StrictStr], Field(description="A mail sorting code.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        focus_point_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.")] = None,
        focus_point_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.")] = None,
        boundary_rect_min_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_min_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_rect_max_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.")] = None,
        boundary_circle_lat: Annotated[Optional[Union[Annotated[float, Field(le=90, strict=True, ge=-90)], Annotated[int, Field(le=90, strict=True, ge=-90)]]], Field(description="The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.")] = None,
        boundary_circle_lon: Annotated[Optional[Union[Annotated[float, Field(le=180, strict=True, ge=-180)], Annotated[int, Field(le=180, strict=True, ge=-180)]]], Field(description="The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.")] = None,
        boundary_circle_radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.")] = None,
        boundary_country: Annotated[Optional[List[StrictStr]], Field(description="A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.")] = None,
        boundary_gid: Annotated[Optional[StrictStr], Field(description="The GID of an area to limit the search to.")] = None,
        layers: Annotated[Optional[List[GeocodingLayer]], Field(description="A list of layers to limit the search to.")] = None,
        sources: Annotated[Optional[List[GeocodingSource]], Field(description="A list of sources to limit the search to.")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The maximum number of results to return.")] = None,
        lang: Annotated[Optional[StrictStr], Field(description="A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find locations matching components (structured forward geocoding).

        The structured search endpoint lets you search for addresses, points of interest, and administrative areas. Rather than a single string which the API must infer meaning from, the structured search endpoint allows you to specify the known components upfront, which is useful in many forward geocoding workflows.

        :param address: A street name, optionally with a house number.
        :type address: str
        :param neighbourhood: Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
        :type neighbourhood: str
        :param borough: A unit within a city (not widely used, but present in places like NYC and Mexico City).
        :type borough: str
        :param locality: The city, village, town, etc. that the place/address is part of.
        :type locality: str
        :param county: Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
        :type county: str
        :param region: Typically the first administrative division within a country. For example, a US state or a Canadian province.
        :type region: str
        :param postalcode: A mail sorting code.
        :type postalcode: str
        :param country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type country: str
        :param focus_point_lat: The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
        :type focus_point_lat: float
        :param focus_point_lon: The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
        :type focus_point_lon: float
        :param boundary_rect_min_lat: Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lat: float
        :param boundary_rect_max_lat: Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lat: float
        :param boundary_rect_min_lon: Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_min_lon: float
        :param boundary_rect_max_lon: Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
        :type boundary_rect_max_lon: float
        :param boundary_circle_lat: The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
        :type boundary_circle_lat: float
        :param boundary_circle_lon: The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
        :type boundary_circle_lon: float
        :param boundary_circle_radius: The radius of the circle (in kilometers) to limit the search to. Defaults to 50km (search) or 1km (reverse) if unspecified.
        :type boundary_circle_radius: float
        :param boundary_country: A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
        :type boundary_country: List[str]
        :param boundary_gid: The GID of an area to limit the search to.
        :type boundary_gid: str
        :param layers: A list of layers to limit the search to.
        :type layers: List[GeocodingLayer]
        :param sources: A list of sources to limit the search to.
        :type sources: List[GeocodingSource]
        :param size: The maximum number of results to return.
        :type size: int
        :param lang: A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
        :type lang: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_structured_serialize(
            address=address,
            neighbourhood=neighbourhood,
            borough=borough,
            locality=locality,
            county=county,
            region=region,
            postalcode=postalcode,
            country=country,
            focus_point_lat=focus_point_lat,
            focus_point_lon=focus_point_lon,
            boundary_rect_min_lat=boundary_rect_min_lat,
            boundary_rect_max_lat=boundary_rect_max_lat,
            boundary_rect_min_lon=boundary_rect_min_lon,
            boundary_rect_max_lon=boundary_rect_max_lon,
            boundary_circle_lat=boundary_circle_lat,
            boundary_circle_lon=boundary_circle_lon,
            boundary_circle_radius=boundary_circle_radius,
            boundary_country=boundary_country,
            boundary_gid=boundary_gid,
            layers=layers,
            sources=sources,
            size=size,
            lang=lang,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeocodeResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_structured_serialize(
        self,
        address,
        neighbourhood,
        borough,
        locality,
        county,
        region,
        postalcode,
        country,
        focus_point_lat,
        focus_point_lon,
        boundary_rect_min_lat,
        boundary_rect_max_lat,
        boundary_rect_min_lon,
        boundary_rect_max_lon,
        boundary_circle_lat,
        boundary_circle_lon,
        boundary_circle_radius,
        boundary_country,
        boundary_gid,
        layers,
        sources,
        size,
        lang,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'boundary.country': 'csv',
            'layers': 'csv',
            'sources': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if address is not None:
            
            _query_params.append(('address', address))
            
        if neighbourhood is not None:
            
            _query_params.append(('neighbourhood', neighbourhood))
            
        if borough is not None:
            
            _query_params.append(('borough', borough))
            
        if locality is not None:
            
            _query_params.append(('locality', locality))
            
        if county is not None:
            
            _query_params.append(('county', county))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if postalcode is not None:
            
            _query_params.append(('postalcode', postalcode))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if focus_point_lat is not None:
            
            _query_params.append(('focus.point.lat', focus_point_lat))
            
        if focus_point_lon is not None:
            
            _query_params.append(('focus.point.lon', focus_point_lon))
            
        if boundary_rect_min_lat is not None:
            
            _query_params.append(('boundary.rect.min_lat', boundary_rect_min_lat))
            
        if boundary_rect_max_lat is not None:
            
            _query_params.append(('boundary.rect.max_lat', boundary_rect_max_lat))
            
        if boundary_rect_min_lon is not None:
            
            _query_params.append(('boundary.rect.min_lon', boundary_rect_min_lon))
            
        if boundary_rect_max_lon is not None:
            
            _query_params.append(('boundary.rect.max_lon', boundary_rect_max_lon))
            
        if boundary_circle_lat is not None:
            
            _query_params.append(('boundary.circle.lat', boundary_circle_lat))
            
        if boundary_circle_lon is not None:
            
            _query_params.append(('boundary.circle.lon', boundary_circle_lon))
            
        if boundary_circle_radius is not None:
            
            _query_params.append(('boundary.circle.radius', boundary_circle_radius))
            
        if boundary_country is not None:
            
            _query_params.append(('boundary.country', boundary_country))
            
        if boundary_gid is not None:
            
            _query_params.append(('boundary.gid', boundary_gid))
            
        if layers is not None:
            
            _query_params.append(('layers', layers))
            
        if sources is not None:
            
            _query_params.append(('sources', sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if lang is not None:
            
            _query_params.append(('lang', lang))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/geocoding/v1/search/structured',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


